/************************************************************
 *  SessionEngine.gs â€” /storage (BLOCK 1/2)
 *  User Session Load / Save / Create
 ************************************************************/

const SessionEngine = {

  /************************************************************
   * ðŸ“„ GET SHEET REFERENCE
   ************************************************************/
  getSheet() {
    return CONFIG.getUserSessionsSheet();
  },

  /************************************************************
   * ðŸ“¥ GET SESSION WITHOUT CREATING
   ************************************************************/
  getSession(whatsAppNumber) {
    const sheet = this.getSheet();
    const data = sheet.getDataRange().getValues();

    // Header row
    const header = data[0];
    const idx = {
      number: header.indexOf("WhatsApp_Number"),
      step: header.indexOf("Current_Step_Code"),
      flow: header.indexOf("Flow_Type"),
      region: header.indexOf("Region_Group"),
      lang: header.indexOf("Preferred_Language"),
      temp: header.indexOf("Temp_Data_Json"),
      updated: header.indexOf("Updated_At"),
    };

    for (let i = 1; i < data.length; i++) {
      const row = data[i];

      if (String(row[idx.number]) === String(whatsAppNumber)) {
        const temp = Utils.safeParse(row[idx.temp], {});
        return this._hydrateSession({
          _rowIndex: i + 1,
          WhatsApp_Number: row[idx.number],
          Current_Step_Code: row[idx.step],
          Flow_Type: row[idx.flow],
          Region_Group: row[idx.region],
          Preferred_Language: row[idx.lang],
          Temp_Data_Json: temp,
          Updated_At: row[idx.updated],
          _multiStartTime: null,
          _askedDone: false,
          _lastMediaUrl: null,
        });
      }
    }

    return null;
  },

  /************************************************************
   * ðŸ“¥ LOAD SESSION BY WHATSAPP NUMBER
   ************************************************************/
  load(whatsAppNumber) {
    const sheet = CONFIG.getUserSessionsSheet();
    const data = sheet.getDataRange().getValues();

    // Header row
    const header = data[0];
    const idx = {
      number: header.indexOf("WhatsApp_Number"),
      step: header.indexOf("Current_Step_Code"),
      flow: header.indexOf("Flow_Type"),
      region: header.indexOf("Region_Group"),
      lang: header.indexOf("Preferred_Language"),
      temp: header.indexOf("Temp_Data_Json"),
      updated: header.indexOf("Updated_At"),
    };

    for (let i = 1; i < data.length; i++) {
      const row = data[i];

      if (String(row[idx.number]) === String(whatsAppNumber)) {
        // Found â†’ convert row into session object
        const temp = Utils.safeParse(row[idx.temp], {});
        return this._hydrateSession({
          RowIndex: i + 1, // actual row number in sheet
          WhatsApp_Number: row[idx.number],
          Current_Step_Code: row[idx.step],
          Flow_Type: row[idx.flow],
          Region_Group: row[idx.region],
          Preferred_Language: row[idx.lang],
          Temp_Data_Json: temp,
          Updated_At: row[idx.updated],

          // Multi-reply & media-temporary runtime values
          _multiStartTime: null,
          _askedDone: false,
          _lastMediaUrl: null,
        });
      }
    }

    // Not found â†’ create a new session
    return this.createNewSession(whatsAppNumber);
  },

  createNewSession(number) {
    const sheet = this.getSheet();
    const now = Utils.formatDate(new Date());
    const region = Utils.detectRegion(number);

    const row = [
      number,
      "LANG_MENU",
      "",
      region,
      "",
      "{}",
      now
    ];

    sheet.appendRow(row);

    return {
      WhatsApp_Number: number,
      Current_Step_Code: "LANG_MENU",
      Flow_Type: "",
      Region_Group: region,
      Preferred_Language: "",
      Temp_Data_Json: {},
      Updated_At: now,
      _rowIndex: sheet.getLastRow(),
      RowIndex: sheet.getLastRow()
    };
  },

  /************************************************************
   * ðŸ†• CREATE NEW SESSION
   ************************************************************/
  create(whatsAppNumber) {
    const sheet = CONFIG.getUserSessionsSheet();
    sheet.appendRow([
      whatsAppNumber,     // WhatsApp_Number
      "",                 // Current_Step_Code
      "",                 // Flow_Type
      "",                 // Region_Group
      "",                 // Preferred_Language
      "{}",               // Temp_Data_Json
      Utils.formatDate(new Date()), // Updated_At
    ]);

    const lastRow = sheet.getLastRow();

    return this._hydrateSession({
      RowIndex: lastRow,
      WhatsApp_Number: whatsAppNumber,
      Current_Step_Code: "",
      Flow_Type: "",
      Region_Group: region,
      Preferred_Language: "",
      Temp_Data_Json: {},
      Updated_At: now,
      _rowIndex: sheet.getLastRow(),
      RowIndex: sheet.getLastRow()
    });
  },

};
/************************************************************
 *  SessionEngine.gs â€” /storage (BLOCK 2/2)
 *  Save, Update, Purge Expired, Helpers
 ************************************************************/

Object.assign(SessionEngine, {

  /************************************************************
   * ðŸ’¾ SAVE SESSION BACK TO SHEET
   ************************************************************/
  saveSession(session) {
    if (session && !session.RowIndex && session._rowIndex) {
      session.RowIndex = session._rowIndex;
    }
    return this.save(session);
  },

  save(session) {
    const sheet = CONFIG.getUserSessionsSheet();

    if (!session.RowIndex) {
      return; // Should never happen
    }

    const normalized = this._normalizeTemp(session);
    const row = normalized.RowIndex;

    sheet.getRange(row, 1, 1, 7).setValues([[
      normalized.WhatsApp_Number,
      normalized.Current_Step_Code,
      normalized.Flow_Type,
      normalized.Region_Group,
      normalized.Preferred_Language,
      Utils.safeStringify(normalized.Temp_Data_Json),
      Utils.formatDate(new Date())
    ]]);
  },

  /************************************************************
   * ðŸ”„ UPDATE CURRENT STEP
   ************************************************************/
  updateStep(session, stepCode) {
    session.Current_Step_Code = stepCode;
    session.Updated_At = new Date();
    this.save(session);
  },

  /************************************************************
   * ðŸ” CLEAR TEMP DATA
   ************************************************************/
  clearTemp(session) {
    session.Temp_Data_Json = {};
    session.Temp = {};
    session.Temp_Data = {};
    session._multiStartTime = null;
    session._askedDone = false;
    session._lastMediaUrl = null;
    this.save(session);
  },

  /************************************************************
   * â™» RESET MULTI-REPLY CONTEXT
   ************************************************************/
  resetMultiReply(session) {
    session._multiStartTime = null;
    session._askedDone = false;
    this.save(session);
  },

  /************************************************************
   * âš  PURGE EXPIRED SESSIONS
   * Delete sessions older than X days (CONFIG.SESSION_EXPIRY_DAYS)
   ************************************************************/
  purgeExpiredSessions() {
    const sheet = CONFIG.getUserSessionsSheet();
    const data = sheet.getDataRange().getValues();

    if (data.length <= 1) return; // no sessions

    const header = data[0];
    const idxUpdated = header.indexOf("Updated_At");
    const expiryMs = CONFIG.SESSION_EXPIRY_DAYS * 24 * 60 * 60 * 1000;

    const now = new Date().getTime();

    // We collect rows to delete AFTER loop (safe indexing)
    const rowsToDelete = [];

    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const updatedAt = new Date(row[idxUpdated]).getTime();
      const age = now - updatedAt;

      if (age >= expiryMs) {
        rowsToDelete.push(i + 1); // actual row index
      }
    }

    // Delete in reverse order
    for (let r = rowsToDelete.length - 1; r >= 0; r--) {
      sheet.deleteRow(rowsToDelete[r]);
    }
  },

  /************************************************************
   * ðŸ” RESET SESSION (light reset)
   ************************************************************/
  reset(session) {
    session.Current_Step_Code = "";
    session.Flow_Type = "";
    this.clearTemp(session);
  },

  /************************************************************
   * ðŸ”„ RESET PARTIAL (keep language/region)
   ************************************************************/
  resetPartial(session) {
    session.Flow_Type = "";
    session.Current_Step_Code = "";
    this.clearTemp(session);
  },

  /************************************************************
   * ðŸ§¼ RESET FULL (clear language/region too)
   ************************************************************/
  resetFull(session) {
    session.Flow_Type = "";
    session.Current_Step_Code = "";
    session.Region_Group = "";
    session.Preferred_Language = "";
    this.clearTemp(session);
  },

  /************************************************************
   * â± REFRESH TIMESTAMP ONLY
   ************************************************************/
  refresh(session) {
    session.Updated_At = new Date();
    this.save(session);
  },

  /************************************************************
   * â³ CHECK INACTIVITY TIMEOUT
   ************************************************************/
  isExpired(session) {
    const updated = new Date(session.Updated_At || 0).getTime();
    if (!updated) return false;
    const diff = Date.now() - updated;
    const max = CONFIG.INACTIVITY_TIMEOUT_HOURS * 60 * 60 * 1000;
    return diff >= max;
  },

  /************************************************************
   * ðŸ”’ HELPER: NORMALIZE TEMP STRUCTURE
   ************************************************************/
  _normalizeTemp(session) {
    let temp = session.Temp_Data_Json || session.Temp || session.Temp_Data || {};

    if (typeof temp === "string") {
      temp = Utils.safeParse(temp, {});
    }

    const meta = temp._session_meta || {};

    session._multiStartTime = session._multiStartTime || meta.multiStartTime || null;
    session._askedDone = typeof session._askedDone === "boolean" ? session._askedDone : !!meta.askedDone;
    session._lastMediaUrl = session._lastMediaUrl || meta.lastMediaUrl || null;

    const hasMeta = !!(session._multiStartTime || session._askedDone || session._lastMediaUrl);
    if (hasMeta) {
      temp._session_meta = {
        multiStartTime: session._multiStartTime || null,
        askedDone: !!session._askedDone,
        lastMediaUrl: session._lastMediaUrl || null,
      };
    } else {
      delete temp._session_meta;
    }

    session.Temp_Data_Json = temp;
    session.Temp = temp;
    session.Temp_Data = temp;
    return session;
  },

  /************************************************************
   * ðŸª„ HELPER: HYDRATE SESSION WITH TEMP MIRRORS
   ************************************************************/
  _hydrateSession(session) {
    const normalized = this._normalizeTemp(session);
    normalized.RowIndex = session.RowIndex || session._rowIndex || normalized.RowIndex;
    normalized.Updated_At = session.Updated_At || new Date();
    return normalized;
  },

});

// Backward-compatible alias for flows expecting `Session.*`
const Session = SessionEngine;

